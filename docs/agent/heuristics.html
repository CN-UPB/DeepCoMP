<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>deepcomp.agent.heuristics API documentation</title>
<meta name="description" content="Heuristic algorithms to use as baseline. Only work as multi-agent, not central (would be the same anyways)." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>deepcomp.agent.heuristics</code></h1>
</header>
<section id="section-intro">
<p>Heuristic algorithms to use as baseline. Only work as multi-agent, not central (would be the same anyways).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Heuristic algorithms to use as baseline. Only work as multi-agent, not central (would be the same anyways).
&#34;&#34;&#34;
import numpy as np

from deepcomp.agent.base import MultiAgent


class GreedyBestSelection(MultiAgent):
    &#34;&#34;&#34;
    Agent that is always connected to at most one BS. Greedily chooses the BS with highest achievable data rate.
    This is comparable to 3GPP LTE cell selection based on highest SINR (with a hysteresis threshold of 0)
    &#34;&#34;&#34;
    def compute_action(self, obs, policy_id):
        &#34;&#34;&#34;
        Compute an action for one UE by connecting to the BS with highest data rate (if not connected yet).
        Gets called for all UEs by simulator.

        :param obs: Observation of a UE
        :param policy_id: Ignored since the heuristic behaves identically for all UEs; just based on obs.
        :return: Selected action: 0 = noop. 1-n = index of BS +1 to connect/disconnect
        &#34;&#34;&#34;
        # identify BS with highest data rate; in case of a tie, take the first one
        best_bs = np.argmax(obs[&#39;dr&#39;])
        # if already connected to this BS, stay connected = do nothing
        if obs[&#39;connected&#39;][best_bs]:
            return 0
        # if connected to other BS, disconnect first
        if sum(obs[&#39;connected&#39;]) &gt; 0:
            conn_bs = obs[&#39;connected&#39;].index(1)
            return conn_bs + 1
        # else: not connected yet --&gt; connect to best BS
        return best_bs + 1


class GreedyAllSelection(MultiAgent):
    &#34;&#34;&#34;Agent that always greedily connects to all BS.&#34;&#34;&#34;
    def compute_action(self, obs, policy_id):
        &#34;&#34;&#34;
        Compute action for a UE. Try to connect to all BS. Prioritize BS with higher data rate.

        :param obs: Observations of the UE
        :param policy_id: Ignored
        :return: Action for the UE
        &#34;&#34;&#34;
        # identify BS that are not yet connected
        disconn_bs = [idx for idx, conn in enumerate(obs[&#39;connected&#39;]) if not conn]
        # if connected to all BS already, do nothing
        if len(disconn_bs) == 0:
            return 0
        # else connect to the BS with the highest data rate
        best_bs = disconn_bs[0]
        best_dr = obs[&#39;dr&#39;][best_bs]
        for bs in disconn_bs:
            if obs[&#39;dr&#39;][bs] &gt; best_dr:
                best_bs = bs
                best_dr = obs[&#39;dr&#39;][bs]
        # 0 = noop --&gt; select BS with BS index + 1
        return best_bs + 1


class DynamicSelection(MultiAgent):
    &#34;&#34;&#34;
    Heuristic that dynamically selects cells per UE depending on the SINR.
    It always selects the strongest cell with SINR-1st and all cells that are within epsilon * SINR-1st.

    Based on the following paper: &#39;Multi-point fairness in resource allocation for C-RAN downlink CoMP transmission&#39;
    https://jwcn-eurasipjournals.springeropen.com/articles/10.1186/s13638-015-0501-4
    &#34;&#34;&#34;
    def __init__(self, epsilon):
        &#34;&#34;&#34;
        :param epsilon: Scaling factor
        &#34;&#34;&#34;
        super().__init__()
        self.epsilon = epsilon

    def compute_action(self, obs, policy_id):
        &#34;&#34;&#34;Select strongest BS and all that are within epsilon * SINR of that BS&#34;&#34;&#34;
        # get set of selected cells
        best_snr = max(obs[&#39;dr&#39;])
        threshold = best_snr * self.epsilon
        selected_bs = [idx for idx, snr in enumerate(obs[&#39;dr&#39;]) if snr &gt;= threshold]

        connected_bs = [idx for idx, conn in enumerate(obs[&#39;connected&#39;]) if conn]
        # disconnect from any BS not in the set of selected BS
        for bs in connected_bs:
            if bs not in selected_bs:
                # 0 = noop --&gt; select BS with BS index + 1
                return bs + 1

        # then connect to BS inside set, starting with the strongest --&gt; sort with decreasing SINR
        selected_bs_sorted = sorted(selected_bs, key=lambda idx: obs[&#39;dr&#39;][idx], reverse=True)
        for bs in selected_bs_sorted:
            if not obs[&#39;connected&#39;][bs]:
                return bs + 1

        # else do nothing
        return 0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="deepcomp.agent.heuristics.DynamicSelection"><code class="flex name class">
<span>class <span class="ident">DynamicSelection</span></span>
<span>(</span><span>epsilon)</span>
</code></dt>
<dd>
<div class="desc"><p>Heuristic that dynamically selects cells per UE depending on the SINR.
It always selects the strongest cell with SINR-1st and all cells that are within epsilon * SINR-1st.</p>
<p>Based on the following paper: 'Multi-point fairness in resource allocation for C-RAN downlink CoMP transmission'
<a href="https://jwcn-eurasipjournals.springeropen.com/articles/10.1186/s13638-015-0501-4">https://jwcn-eurasipjournals.springeropen.com/articles/10.1186/s13638-015-0501-4</a></p>
<p>:param epsilon: Scaling factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicSelection(MultiAgent):
    &#34;&#34;&#34;
    Heuristic that dynamically selects cells per UE depending on the SINR.
    It always selects the strongest cell with SINR-1st and all cells that are within epsilon * SINR-1st.

    Based on the following paper: &#39;Multi-point fairness in resource allocation for C-RAN downlink CoMP transmission&#39;
    https://jwcn-eurasipjournals.springeropen.com/articles/10.1186/s13638-015-0501-4
    &#34;&#34;&#34;
    def __init__(self, epsilon):
        &#34;&#34;&#34;
        :param epsilon: Scaling factor
        &#34;&#34;&#34;
        super().__init__()
        self.epsilon = epsilon

    def compute_action(self, obs, policy_id):
        &#34;&#34;&#34;Select strongest BS and all that are within epsilon * SINR of that BS&#34;&#34;&#34;
        # get set of selected cells
        best_snr = max(obs[&#39;dr&#39;])
        threshold = best_snr * self.epsilon
        selected_bs = [idx for idx, snr in enumerate(obs[&#39;dr&#39;]) if snr &gt;= threshold]

        connected_bs = [idx for idx, conn in enumerate(obs[&#39;connected&#39;]) if conn]
        # disconnect from any BS not in the set of selected BS
        for bs in connected_bs:
            if bs not in selected_bs:
                # 0 = noop --&gt; select BS with BS index + 1
                return bs + 1

        # then connect to BS inside set, starting with the strongest --&gt; sort with decreasing SINR
        selected_bs_sorted = sorted(selected_bs, key=lambda idx: obs[&#39;dr&#39;][idx], reverse=True)
        for bs in selected_bs_sorted:
            if not obs[&#39;connected&#39;][bs]:
                return bs + 1

        # else do nothing
        return 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="deepcomp.agent.base.MultiAgent" href="base.html#deepcomp.agent.base.MultiAgent">MultiAgent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="deepcomp.agent.heuristics.DynamicSelection.compute_action"><code class="name flex">
<span>def <span class="ident">compute_action</span></span>(<span>self, obs, policy_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Select strongest BS and all that are within epsilon * SINR of that BS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_action(self, obs, policy_id):
    &#34;&#34;&#34;Select strongest BS and all that are within epsilon * SINR of that BS&#34;&#34;&#34;
    # get set of selected cells
    best_snr = max(obs[&#39;dr&#39;])
    threshold = best_snr * self.epsilon
    selected_bs = [idx for idx, snr in enumerate(obs[&#39;dr&#39;]) if snr &gt;= threshold]

    connected_bs = [idx for idx, conn in enumerate(obs[&#39;connected&#39;]) if conn]
    # disconnect from any BS not in the set of selected BS
    for bs in connected_bs:
        if bs not in selected_bs:
            # 0 = noop --&gt; select BS with BS index + 1
            return bs + 1

    # then connect to BS inside set, starting with the strongest --&gt; sort with decreasing SINR
    selected_bs_sorted = sorted(selected_bs, key=lambda idx: obs[&#39;dr&#39;][idx], reverse=True)
    for bs in selected_bs_sorted:
        if not obs[&#39;connected&#39;][bs]:
            return bs + 1

    # else do nothing
    return 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="deepcomp.agent.heuristics.GreedyAllSelection"><code class="flex name class">
<span>class <span class="ident">GreedyAllSelection</span></span>
</code></dt>
<dd>
<div class="desc"><p>Agent that always greedily connects to all BS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GreedyAllSelection(MultiAgent):
    &#34;&#34;&#34;Agent that always greedily connects to all BS.&#34;&#34;&#34;
    def compute_action(self, obs, policy_id):
        &#34;&#34;&#34;
        Compute action for a UE. Try to connect to all BS. Prioritize BS with higher data rate.

        :param obs: Observations of the UE
        :param policy_id: Ignored
        :return: Action for the UE
        &#34;&#34;&#34;
        # identify BS that are not yet connected
        disconn_bs = [idx for idx, conn in enumerate(obs[&#39;connected&#39;]) if not conn]
        # if connected to all BS already, do nothing
        if len(disconn_bs) == 0:
            return 0
        # else connect to the BS with the highest data rate
        best_bs = disconn_bs[0]
        best_dr = obs[&#39;dr&#39;][best_bs]
        for bs in disconn_bs:
            if obs[&#39;dr&#39;][bs] &gt; best_dr:
                best_bs = bs
                best_dr = obs[&#39;dr&#39;][bs]
        # 0 = noop --&gt; select BS with BS index + 1
        return best_bs + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="deepcomp.agent.base.MultiAgent" href="base.html#deepcomp.agent.base.MultiAgent">MultiAgent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="deepcomp.agent.heuristics.GreedyAllSelection.compute_action"><code class="name flex">
<span>def <span class="ident">compute_action</span></span>(<span>self, obs, policy_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute action for a UE. Try to connect to all BS. Prioritize BS with higher data rate.</p>
<p>:param obs: Observations of the UE
:param policy_id: Ignored
:return: Action for the UE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_action(self, obs, policy_id):
    &#34;&#34;&#34;
    Compute action for a UE. Try to connect to all BS. Prioritize BS with higher data rate.

    :param obs: Observations of the UE
    :param policy_id: Ignored
    :return: Action for the UE
    &#34;&#34;&#34;
    # identify BS that are not yet connected
    disconn_bs = [idx for idx, conn in enumerate(obs[&#39;connected&#39;]) if not conn]
    # if connected to all BS already, do nothing
    if len(disconn_bs) == 0:
        return 0
    # else connect to the BS with the highest data rate
    best_bs = disconn_bs[0]
    best_dr = obs[&#39;dr&#39;][best_bs]
    for bs in disconn_bs:
        if obs[&#39;dr&#39;][bs] &gt; best_dr:
            best_bs = bs
            best_dr = obs[&#39;dr&#39;][bs]
    # 0 = noop --&gt; select BS with BS index + 1
    return best_bs + 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="deepcomp.agent.heuristics.GreedyBestSelection"><code class="flex name class">
<span>class <span class="ident">GreedyBestSelection</span></span>
</code></dt>
<dd>
<div class="desc"><p>Agent that is always connected to at most one BS. Greedily chooses the BS with highest achievable data rate.
This is comparable to 3GPP LTE cell selection based on highest SINR (with a hysteresis threshold of 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GreedyBestSelection(MultiAgent):
    &#34;&#34;&#34;
    Agent that is always connected to at most one BS. Greedily chooses the BS with highest achievable data rate.
    This is comparable to 3GPP LTE cell selection based on highest SINR (with a hysteresis threshold of 0)
    &#34;&#34;&#34;
    def compute_action(self, obs, policy_id):
        &#34;&#34;&#34;
        Compute an action for one UE by connecting to the BS with highest data rate (if not connected yet).
        Gets called for all UEs by simulator.

        :param obs: Observation of a UE
        :param policy_id: Ignored since the heuristic behaves identically for all UEs; just based on obs.
        :return: Selected action: 0 = noop. 1-n = index of BS +1 to connect/disconnect
        &#34;&#34;&#34;
        # identify BS with highest data rate; in case of a tie, take the first one
        best_bs = np.argmax(obs[&#39;dr&#39;])
        # if already connected to this BS, stay connected = do nothing
        if obs[&#39;connected&#39;][best_bs]:
            return 0
        # if connected to other BS, disconnect first
        if sum(obs[&#39;connected&#39;]) &gt; 0:
            conn_bs = obs[&#39;connected&#39;].index(1)
            return conn_bs + 1
        # else: not connected yet --&gt; connect to best BS
        return best_bs + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="deepcomp.agent.base.MultiAgent" href="base.html#deepcomp.agent.base.MultiAgent">MultiAgent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="deepcomp.agent.heuristics.GreedyBestSelection.compute_action"><code class="name flex">
<span>def <span class="ident">compute_action</span></span>(<span>self, obs, policy_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an action for one UE by connecting to the BS with highest data rate (if not connected yet).
Gets called for all UEs by simulator.</p>
<p>:param obs: Observation of a UE
:param policy_id: Ignored since the heuristic behaves identically for all UEs; just based on obs.
:return: Selected action: 0 = noop. 1-n = index of BS +1 to connect/disconnect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_action(self, obs, policy_id):
    &#34;&#34;&#34;
    Compute an action for one UE by connecting to the BS with highest data rate (if not connected yet).
    Gets called for all UEs by simulator.

    :param obs: Observation of a UE
    :param policy_id: Ignored since the heuristic behaves identically for all UEs; just based on obs.
    :return: Selected action: 0 = noop. 1-n = index of BS +1 to connect/disconnect
    &#34;&#34;&#34;
    # identify BS with highest data rate; in case of a tie, take the first one
    best_bs = np.argmax(obs[&#39;dr&#39;])
    # if already connected to this BS, stay connected = do nothing
    if obs[&#39;connected&#39;][best_bs]:
        return 0
    # if connected to other BS, disconnect first
    if sum(obs[&#39;connected&#39;]) &gt; 0:
        conn_bs = obs[&#39;connected&#39;].index(1)
        return conn_bs + 1
    # else: not connected yet --&gt; connect to best BS
    return best_bs + 1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="deepcomp.agent" href="index.html">deepcomp.agent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="deepcomp.agent.heuristics.DynamicSelection" href="#deepcomp.agent.heuristics.DynamicSelection">DynamicSelection</a></code></h4>
<ul class="">
<li><code><a title="deepcomp.agent.heuristics.DynamicSelection.compute_action" href="#deepcomp.agent.heuristics.DynamicSelection.compute_action">compute_action</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="deepcomp.agent.heuristics.GreedyAllSelection" href="#deepcomp.agent.heuristics.GreedyAllSelection">GreedyAllSelection</a></code></h4>
<ul class="">
<li><code><a title="deepcomp.agent.heuristics.GreedyAllSelection.compute_action" href="#deepcomp.agent.heuristics.GreedyAllSelection.compute_action">compute_action</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="deepcomp.agent.heuristics.GreedyBestSelection" href="#deepcomp.agent.heuristics.GreedyBestSelection">GreedyBestSelection</a></code></h4>
<ul class="">
<li><code><a title="deepcomp.agent.heuristics.GreedyBestSelection.compute_action" href="#deepcomp.agent.heuristics.GreedyBestSelection.compute_action">compute_action</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>